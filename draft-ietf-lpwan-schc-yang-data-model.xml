<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.14 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-lpwan-schc-yang-data-model-12" category="std">

  <front>
    <title abbrev="LPWAN SCHC YANG module">Data Model for Static Context Header Compression (SCHC)</title>

    <author initials="A." surname="Minaburo" fullname="Ana Minaburo">
      <organization>Acklio</organization>
      <address>
        <postal>
          <street>1137A avenue des Champs Blancs</street>
          <city>35510 Cesson-Sevigne Cedex</city>
          <country>France</country>
        </postal>
        <email>ana@ackl.io</email>
      </address>
    </author>
    <author initials="L." surname="Toutain" fullname="Laurent Toutain">
      <organization>Institut MINES TELECOM; IMT Atlantique</organization>
      <address>
        <postal>
          <street>2 rue de la Chataigneraie</street> <street>CS 17607</street>
          <city>35576 Cesson-Sevigne Cedex</city>
          <country>France</country>
        </postal>
        <email>Laurent.Toutain@imt-atlantique.fr</email>
      </address>
    </author>

    <date year="2022" month="May" day="25"/>

    
    <workgroup>lpwan Working Group</workgroup>
    

    <abstract>


<t>This document describes a YANG data model for the SCHC (Static Context Header Compression) 
compression and fragmentation rules.</t>



    </abstract>


  </front>

  <middle>


<section anchor="Introduction" title="Introduction">

<t>SCHC is a compression and fragmentation mechanism for constrained networks defined in <xref target="RFC8724"/>.
It is based on a static context shared by two entities at the boundary of the constrained network.
<xref target="RFC8724"/> provides a non formal representation of the rules used either for compression/decompression (or C/D)
or fragmentation/reassembly (or F/R). The goal of this document is to formalize the description of the rules to offer:</t>

<t><list style="symbols">
  <t>the same definition on both ends, even if the internal representation is different.</t>
  <t>an update of the other end to set up some specific values (e.g. IPv6 prefix, Destination address,…)</t>
  <t>…</t>
</list></t>

<t><xref target="I-D.ietf-lpwan-architecture"/> illustrates the use of rule exchanges.</t>

<t>This document defines a YANG module <xref target="RFC7950"/> to represent both compression and fragmentation rules, which leads to common representation for values for all the rules elements.</t>

</section>
<section anchor="requirements-language" title="Requirements Language">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
   “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and
   “OPTIONAL” in this document are to be interpreted as described in Ò<xref target="RFC2119"/>.</t>

</section>
<section anchor="schc-rules" title="SCHC rules">

<t>SCHC is a compression and fragmentation mechanism for constrained networks defined in <xref target="RFC8724"/>.
It is based on a static context shared by two entities at the boundary of the constrained network.
<xref target="RFC8724"/> provides a non formal representation of the rules used either for compression/decompression (or C/D)
or fragmentation/reassembly (or F/R). The goal of this document is to formalize the description of the rules to offer:</t>

<t><list style="symbols">
  <t>the same definition on both ends, even if the internal representation is different.</t>
  <t>an update of the other end to set up some specific values (e.g. IPv6 prefix, Destination address,…)</t>
  <t>…</t>
</list></t>

<t>This document defines a YANG module to represent both compression and fragmentation rules, which leads to common representation for values for all the rules elements.</t>

<t>SCHC compression is generic, the main mechanism does not refer
to a specific protocol. Any header field is abstracted through an ID, a position, a direction, and a value that can be a numerical
value or a string. <xref target="RFC8724"/> and <xref target="RFC8824"/> specify fields for IPv6, UDP, CoAP and OSCORE.</t>

<t>SCHC fragmentation requires a set of common parameters that are included in a rule. These parameters are defined in <xref target="RFC8724"/>.</t>

<t>The YANG model allows to select the compression or the fragmentation using the feature command.</t>

<figure title="Feature for compression and fragmentation." anchor="Fig-feature"><artwork><![CDATA[
  feature compression {
    description
      "SCHC compression capabilities are taken into account";
  }

  feature fragmentation {
    description
      "SCHC fragmentation capabilities are taken into account";
  }
]]></artwork></figure>

<section anchor="comp_types" title="Compression Rules">

<t><xref target="RFC8724"/> proposes a non formal representation of the compression rule.
A compression context for a device is composed of a set of rules. Each rule contains information to
describe a specific field in the header to be compressed.</t>

<figure title="Compression Decompression Context" anchor="Fig-ctxt"><artwork><![CDATA[
  +-----------------------------------------------------------------+
  |                      Rule N                                     |
 +-----------------------------------------------------------------+|
 |                    Rule i                                       ||
+-----------------------------------------------------------------+||
|  (FID)            Rule 1                                        |||
|+-------+--+--+--+------------+-----------------+---------------+|||
||Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+--+------------+-----------------+---------------+|||
||Field 2|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||||
|+-------+--+--+--+------------+-----------------+---------------+|||
||...    |..|..|..|   ...      | ...             | ...           ||||
|+-------+--+--+--+------------+-----------------+---------------+||/
||Field N|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|||
|+-------+--+--+--+------------+-----------------+---------------+|/
|                                                                 |        
\-----------------------------------------------------------------/  

]]></artwork></figure>

</section>
<section anchor="identifier-generation" title="Identifier generation">

<t>Identifier used in the SCHC YANG Data Model are from the identityref statement to ensure to be globally unique and be easily augmented if needed.  The principle to define a new type based on a group of identityref is the following:</t>

<t><list style="symbols">
  <t>define a main identity ending with the keyword base-type.</t>
  <t>derive all the identities used in the Data Model from this base type.</t>
  <t>create a typedef from this base type.</t>
</list></t>

<t>The example (<xref target="Fig-identityref"/>) shows how an identityref is created for RCS algorithms used during SCHC fragmentation.</t>

<figure title="Principle to define a type based on identityref." anchor="Fig-identityref"><artwork><![CDATA[
 // -- RCS algorithm types

  identity rcs-algorithm-base-type {
    description
      "Identify which algorithm is used to compute RCS.
       The algorithm also defines the size of the RCS field.";
  }

  identity rcs-RFC8724 {
    base rcs-algorithm-base-type;
    description
      "CRC 32 defined as default RCS in RFC8724. RCS is 4 byte-long";
  }

  typedef rcs-algorithm-type {
    type identityref {
      base rcs-algorithm-base-type;
    }
    description
      "type used in rules.";
  }
]]></artwork></figure>

</section>
<section anchor="field-identifier" title="Field Identifier">

<t>In the process of compression, the headers of the original packet are first parsed to create a list of fields. This list of fields is matched against the rules to find the appropriate rule and apply compression.  <xref target="RFC8724"/>  does not state how the field ID value is constructed. 
In examples, identification is done through a string indexed by the protocol name (e.g. IPv6.version, CoAP.version,…).</t>

<t>The current YANG Data Model includes fields definitions found in <xref target="RFC8724"/>, <xref target="RFC8824"/>.</t>

<t>Using the YANG model, each field MUST be identified through a global YANG identityref.<vspace />
A YANG field ID for the protocol always derives from the fid-base-type. Then an identity 
for each protocol is specified using the naming convention fid-&lt;&lt;protocol name»-base-type. 
All possible fields for this protocol MUST derive from the protocol identity. The naming 
convention is “fid” followed by the protocol name and the field name. If a field has 
to be divided into sub-fields, the field identity serves as a base.</t>

<t>The full field-id definition is found in <xref target="annexA"/>. The example <xref target="Fig-ex-field-id"/> 
gives the first field ID definitions. A type is defined for IPv6 protocol, and each 
field is based on it. Note that the DiffServ bits derives from the Traffic Class identity.</t>

<figure title="Definition of identityref for field IDs" anchor="Fig-ex-field-id"><artwork><![CDATA[
  identity fid-base-type {
    description
      "Field ID base type for all fields";
  }

  identity fid-ipv6-base-type {
    base fid-base-type;
    description
      "Field ID base type for IPv6 headers described in RFC 8200";
  }

  identity fid-ipv6-version {
    base fid-ipv6-base-type;
    description
      "IPv6 version field from RFC8200";
  }

  identity fid-ipv6-trafficclass {
    base fid-ipv6-base-type;
    description
      "IPv6 Traffic Class field from RFC8200";
  }

  identity fid-ipv6-trafficclass-ds {
    base fid-ipv6-trafficclass;
    description
      "IPv6 Traffic Class field from RFC8200,
       DiffServ field from RFC3168";
  }
  ...
]]></artwork></figure>

<t>The type associated to this identity is fid-type (cf. <xref target="Fig-field-id-type"/>)</t>

<figure title="Type definition for field IDs" anchor="Fig-field-id-type"><artwork><![CDATA[
  typedef fid-type {
    type identityref {
      base fid-base-type;
    }
    description
      "Field ID generic type.";
  }
]]></artwork></figure>

</section>
<section anchor="field-length" title="Field length">

<t>Field length is either an integer giving the size of a field in bits or a specific function. <xref target="RFC8724"/> defines the
“var” function which allows variable length fields (whose length is expressed in bytes) and <xref target="RFC8824"/> defines the “tkl” function for managing the CoAP
Token length field.</t>

<t>The naming convention is “fl” followed by the function name.</t>

<figure title="Definition of identityref for Field Length" anchor="Fig-ex-field-length"><artwork><![CDATA[
  identity fl-base-type {
    description
      "Used to extend field length functions.";
  }

  identity fl-variable {
    base fl-base-type;
    description
      "Residue length in Byte is sent as defined
       for CoAP in RFC 8824 (cf. 5.3).";
  }

  identity fl-token-length {
    base fl-base-type;
    description
      "Residue length in Byte is sent as defined
       for CoAP in RFC 8824 (cf. 4.5).";
  }
]]></artwork></figure>

<t>The field length function can be defined as an identityref as shown in <xref target="Fig-ex-field-length"/>.</t>

<t>Therefore, the type for field length is a union between an integer giving in bits the size of the length and the identityref (cf. <xref target="Fig-ex-field-length-union"/>).</t>

<figure title="Type definition for field Length" anchor="Fig-ex-field-length-union"><artwork><![CDATA[
  typedef fl-type {
    type union {
      type int64; /* positive integer, expressing length in bits */
      type identityref { /* function */
        base fl-base-type;
      }
    }
    description
      "Field length either a positive integer expressing the size in
       bits or a function defined through an identityref.";
  }
]]></artwork></figure>

</section>
<section anchor="field-position" title="Field position">

<t>Field position is a positive integer which gives the position of a field, the default value is 1, and incremented at each repetition. 
value 0 indicates that the position is not important and is not considered during the rule selection process.</t>

<t>Field position is a positive integer. The type is an uint8.</t>

</section>
<section anchor="direction-indicator" title="Direction Indicator">

<t>The Direction Indicator (di) is used to tell if a field appears in both direction (Bi) or only uplink (Up) or Downlink (Dw).</t>

<figure title="Definition of identityref for direction indicators" anchor="Fig-ex-field-DI"><artwork><![CDATA[
  identity di-base-type {
    description
      "Used to extend direction indicators.";
  }

  identity di-bidirectional {
    base di-base-type;
    description
      "Direction Indication of bidirectionality in
       RFC 8724 (cf. 7.1).";
  }

  identity di-up {
    base di-base-type;
    description
      "Direction Indication of uplink defined in
       RFC 8724 (cf. 7.1).";
  }

  identity di-down {
    base di-base-type;
    description
      "Direction Indication of downlink defined in
       RFC 8724 (cf. 7.1).";
  }
]]></artwork></figure>

<t><xref target="Fig-ex-field-DI"/> gives the identityref for Direction Indicators. The naming convention is “di” followed by the Direction Indicator name.</t>

<t>The type is “di-type” (cf. <xref target="Fig-field-DI-type"/>).</t>

<figure title="Type definition for direction indicators" anchor="Fig-field-DI-type"><artwork><![CDATA[
  typedef di-type {
    type identityref {
      base di-base-type;
    }
    description
      "Direction in LPWAN network, up when emitted by the device,
       down when received by the device, bi when emitted or
       received by the device.";
  }
]]></artwork></figure>

</section>
<section anchor="target_value" title="Target Value">

<t>The Target Value is a list of binary sequences of any length, aligned to the left. <xref target="Fig-ex-TV"/> shows the definition of a single element of a Target Value. In the rule, the structure will be used as a list, with index as a key. The highest index value is used to compute the size of the index sent in residue for the match-mapping CDA. The index allows to specify several values:</t>

<t><list style="symbols">
  <t>For Equal and LSB, Target Value contains a single element. Therefore, the index is set to 0.</t>
  <t>For match-mapping, Target Value can contain several elements. Index values MUST start from 0 and MUST be contiguous.</t>
</list></t>

<figure title="Definition of target value" anchor="Fig-ex-TV"><artwork><![CDATA[
  grouping tv-struct {
    description
      "Defines the target value element. Always a binary type, 
       strings must be converted to binary. field-id allows the 
       conversion to the appropriate type.";
    leaf value {
      type binary;
      description
        "Target Value";
    }
    leaf index {
      type uint16;
      description
        "Index gives the position in the matching-list. If only one
         element is present, index is 0. Otherwise, indicia is the
         the order in the matching list, starting at 0.";
    }
  }
]]></artwork></figure>

</section>
<section anchor="matching-operator" title="Matching Operator">

<t>Matching Operator (MO) is a function applied between a field value provided by the parsed header and the target value. <xref target="RFC8724"/> defines 4 MO as listed in <xref target="Fig-ex-MO"/>.</t>

<figure title="Definition of identityref for Matching Operator " anchor="Fig-ex-MO"><artwork><![CDATA[
  identity mo-base-type {
    description
      "Used to extend Matching Operators with SID values";
  }

  identity mo-equal {
    base mo-base-type;
    description
      "Equal MO as defined in RFC 8724 (cf. 7.3)";
  }

  identity mo-ignore {
    base mo-base-type;
    description
      "Ignore MO as defined in RFC 8724 (cf. 7.3)";
  }

  identity mo-msb {
    base mo-base-type;
    description
      "MSB MO as defined in RFC 8724 (cf. 7.3)";
  }

  identity mo-match-mapping {
    base mo-base-type;
    description
      "match-mapping MO as defined in RFC 8724 (cf. 7.3)";
  }
]]></artwork></figure>

<t>The naming convention is “mo” followed by the MO name.</t>

<t>The type is “mo-type” (cf. <xref target="Fig-MO-type"/>)</t>

<figure title="Type definition for Matching Operator" anchor="Fig-MO-type"><artwork><![CDATA[
  typedef mo-type {
    type identityref {
      base mo-base-type;
    }
    description
      "Matching Operator (MO) to compare fields values with
       target values";
  }
]]></artwork></figure>

<section anchor="matching-operator-arguments" title="Matching Operator arguments">

<t>They are viewed as a list, built with a tv-struct (see chapter <xref target="target_value"/>).</t>

</section>
</section>
<section anchor="compression-decompression-actions" title="Compression Decompression Actions">

<t>Compression Decompression Action (CDA) identifies the function to use for compression or decompression. 
<xref target="RFC8724"/> defines 6 CDA.</t>

<t><xref target="Fig-CDA-type"/> shows some CDA definition, the full definition is in <xref target="annexA"/>.</t>

<figure title="Definition of identityref for  Compresion Decompression Action" anchor="Fig-ex-CDA"><artwork><![CDATA[
  identity cda-base-type {
    description
      "Compression Decompression Actions.";
  }

  identity cda-not-sent {
    base cda-base-type;
    description
      "not-sent CDA as defined in RFC 8724 (cf. 7.4).";
  }

  identity cda-value-sent {
    base cda-base-type;
    description
      "value-sent CDA as defined in RFC 8724 (cf. 7.4).";
  }

  identity cda-lsb {
    base cda-base-type;
    description
      "LSB CDA as defined in RFC 8724 (cf. 7.4).";
  }

  identity cda-mapping-sent {
    base cda-base-type;
    description
      "mapping-sent CDA as defined in RFC 8724 (cf. 7.4).";
  }

  identity cda-compute {
    base cda-base-type;
    description
      "compute-* CDA as defined in RFC 8724 (cf. 7.4)";
  }
    ....
]]></artwork></figure>

<t>The naming convention is “cda” followed by the CDA name.</t>

<figure title="Type definition for Compresion Decompression Action" anchor="Fig-CDA-type"><artwork><![CDATA[
  typedef cda-type {
    type identityref {
      base cda-base-type;
    }
    description
      "Compression Decompression Action to compression or
       decompress a field.";
  }
]]></artwork></figure>

<section anchor="compression-decompression-action-arguments" title="Compression Decompression Action arguments">

<t>Currently no CDA requires arguments, but in the future some CDA may require one or several arguments.
They are viewed as a list, of target-value type.</t>

</section>
</section>
<section anchor="frag_types" title="Fragmentation rule">

<t>Fragmentation is optional in the data model and depends on the presence of the “fragmentation” feature.</t>

<t>Most of the fragmentation parameters are listed in Annex D of <xref target="RFC8724"/>.</t>

<t>Since fragmentation rules work for a specific direction, they MUST contain a mandatory direction indicator.
The type is the same as the one used in compression entries, but bidirectional MUST NOT be used.</t>

<section anchor="fragmentation-mode" title="Fragmentation mode">

<t><xref target="RFC8724"/> defines 3 fragmentation modes:</t>

<t><list style="symbols">
  <t>No Ack: this mode is unidirectionnal, no acknowledgment is sent back.</t>
  <t>Ack Always: each fragmentation window must be explicitly acknowledged before going to the next.</t>
  <t>Ack on Error:  A window is acknowledged only when the receiver detects some missing fragments.</t>
</list></t>

<t><xref target="Fig-frag-mode"/> shows the definition for identifiers from these three modes.</t>

<figure title="Definition of fragmentation mode identifer" anchor="Fig-frag-mode"><artwork><![CDATA[
  identity fragmentation-mode-base-type {
    description
      "fragmentation mode.";
  }

  identity fragmentation-mode-no-ack {
    base fragmentation-mode-base-type;
    description
      "No-ACK of RFC8724.";
  }

  identity fragmentation-mode-ack-always {
    base fragmentation-mode-base-type;
    description
      "ACK-Always of RFC8724.";
  }

  identity fragmentation-mode-ack-on-error {
    base fragmentation-mode-base-type;
    description
      "ACK-on-Error of RFC8724.";
  }

  typedef fragmentation-mode-type {
    type identityref {
      base fragmentation-mode-base-type;
    }
    description
      "type used in rules";
  }
]]></artwork></figure>

<t>The naming convention is “fragmentation-mode” followed by the fragmentation mode name.</t>

</section>
<section anchor="fragmentation-header" title="Fragmentation Header">

<t>A data fragment header, starting with the rule ID can be sent on the fragmentation direction. 
The SCHC header may be composed of (cf. <xref target="Fig-frag-header-8724"/>):</t>

<t><list style="symbols">
  <t>a Datagram Tag (Dtag) identifying the datagram being fragmented if the fragmentation applies concurrently on several datagrams. This field in optional and its length is defined by the rule.</t>
  <t>a Window (W) used in Ack-Always and Ack-on-Error modes. In Ack-Always, its size is 1. In Ack-on-Error, it depends on the rule. This field is not needed in No-Ack mode.</t>
  <t>a Fragment Compressed Number (FCN) indicating the fragment/tile position within the window. This field is mandatory on all modes defined in <xref target="RFC8724"/>, its size is defined by the rule.</t>
</list></t>

<figure title="Data fragment header from RFC8724" anchor="Fig-frag-header-8724"><artwork><![CDATA[
|-- SCHC Fragment Header ----|
         |-- T --|-M-|-- N --|
+-- ... -+- ... -+---+- ... -+--------...-------+~~~~~~~~~~~~~~~~~~~~
| RuleID | DTag  | W |  FCN  | Fragment Payload | padding (as needed)
+-- ... -+- ... -+---+- ... -+--------...-------+~~~~~~~~~~~~~~~~~~~~

]]></artwork></figure>

</section>
<section anchor="last-fragment-format" title="Last fragment format">

<t>The last fragment of a datagram is sent with an RCS (Reassembly Check Sequence) field to detect residual 
transmission error and possible losses in the last window. <xref target="RFC8724"/> defines a single algorithm based on Ethernet 
CRC computation. The identity of the RCS algorithm is shown in <xref target="Fig-frag-RCS"/>.</t>

<figure title="type definition for RCS" anchor="Fig-frag-RCS"><artwork><![CDATA[
  identity rcs-algorithm-base-type {
    description
      "Identify which algorithm is used to compute RCS.
       The algorithm also defines the size of the RCS field.";
  }

  identity rcs-RFC8724 {
    base rcs-algorithm-base-type;
    description
      "CRC 32 defined as default RCS in RFC8724. RCS is 4 byte-long";
  }

  typedef rcs-algorithm-type {
    type identityref {
      base rcs-algorithm-base-type;
    }
    description
      "type used in rules.";
  }
]]></artwork></figure>

<t>The naming convention is “rcs” followed by the algorithm name.</t>

<t>For Ack-on-Error mode, the All-1 fragment may just contain the RCS or can include a tile. The parameters defined in <xref target="Fig-frag-all1-data"/> allows to define the 
behavior:</t>

<t><list style="symbols">
  <t>all1-data-no: the last fragment contains no data, just the RCS</t>
  <t>all1-data-yes: the last fragment includes a single tile and the RCS</t>
  <t>all1-data-sender-choice: the last fragment may or may not contain a single tile. The receiver can detect if a tile is present.</t>
</list></t>

<figure title="type definition for RCS" anchor="Fig-frag-all1-data"><artwork><![CDATA[
  identity all1-data-base-type {
    description
      "Type to define when to send an Acknowledgment message.";
  }

  identity all1-data-no {
    base all1-data-base-type;
    description
      "All1 contains no tiles.";
  }

  identity all1-data-yes {
    base all1-data-base-type;
    description
      "All1 MUST contain a tile.";
  }

  identity all1-data-sender-choice {
    base all1-data-base-type;
    description
      "Fragmentation process chooses to send tiles or not in all1.";
  }

  typedef all1-data-type {
    type identityref {
      base all1-data-base-type;
    }
    description
      "Type used in rules.";
  }
]]></artwork></figure>

<t>The naming convention is “all1-data” followed by the behavior identifier.</t>

</section>
<section anchor="acknowledgment-behavior" title="Acknowledgment behavior">

<t>The acknowledgment fragment header goes in the opposite direction of data. The header is composed of (see <xref target="Fig-frag-ack"/>):</t>

<t><list style="symbols">
  <t>a Dtag (if present).</t>
  <t>a mandatory window as in the data fragment.</t>
  <t>a C bit giving the status of RCS validation.  In case of failure, a bitmap follows, indicating the received tile.</t>
</list></t>

<figure title="Acknowledgment fragment header for RFC8724" anchor="Fig-frag-ack"><artwork><![CDATA[
|--- SCHC ACK Header ----|
         |-- T --|-M-| 1 |
+-- ... -+- ... -+---+---+~~~~~~~~~~~~~~~~~~
| RuleID |  DTag | W |C=1| padding as needed                (success)
+-- ... -+- ... -+---+---+~~~~~~~~~~~~~~~~~~

+-- ... -+- ... -+---+---+------ ... ------+~~~~~~~~~~~~~~~
| RuleID |  DTag | W |C=0|Compressed Bitmap| pad. as needed (failure)
+-- ... -+- ... -+---+---+------ ... ------+~~~~~~~~~~~~~~~

]]></artwork></figure>

<t>For Ack-on-Error, SCHC defines when an acknowledgment can be sent. This can be at any time defined by the layer 2, at the end of a window (FCN All-0) 
or as a response to receiving the last fragment (FCN All-1). The following identifiers (cf. <xref target="Fig-frag-ack-behavior"/>) define the acknowledgment behavior.</t>

<figure title="bitmap generation behavior" anchor="Fig-frag-ack-behavior"><artwork><![CDATA[
  identity ack-behavior-base-type {
    description
      "Define when to send an Acknowledgment .";
  }

  identity ack-behavior-after-All0 {
    base ack-behavior-base-type;
    description
      "Fragmentation expects Ack after sending All0 fragment.";
  }

  identity ack-behavior-after-All1 {
    base ack-behavior-base-type;
    description
      "Fragmentation expects Ack after sending All1 fragment.";
  }

  identity ack-behavior-by-layer2 {
    base ack-behavior-base-type;
    description
      "Layer 2 defines when to send an Ack.";
  }

  typedef ack-behavior-type {
    type identityref {
      base ack-behavior-base-type;
    }
    description
      "Type used in rules.";
  }
]]></artwork></figure>

<t>The naming convention is “ack-behavior” followed by the algorithm name.</t>

</section>
<section anchor="fragmentation-parameters" title="Fragmentation Parameters">

<t>The state machine requires some common values to handle fragmentation:</t>

<t><list style="symbols">
  <t>retransmission-timer expresses, in seconds, the duration before sending an ack request (cf. section 8.2.2.4. of <xref target="RFC8724"/>). If specified, value must be higher or equal to 1.</t>
  <t>inactivity-timer expresses, in seconds, the duration before aborting a fragmentation session (cf. section 8.2.2.4. of <xref target="RFC8724"/>). The value 0 explicitly indicates that this timer is disabled.</t>
  <t>max-ack-requests expresses the number of attempts before aborting (cf. section 8.2.2.4. of <xref target="RFC8724"/>).</t>
  <t>maximum-packet-size rexpresses, in bytes, the larger packet size that can be reassembled.</t>
</list></t>

<t>They are defined as unsigned integers, see <xref target="annexA"/>.</t>

</section>
<section anchor="layer-2-parameters" title="Layer 2 parameters">

<t>The data model includes two parameters needed for fragmentation:</t>

<t><list style="symbols">
  <t>l2-word-size: <xref target="RFC8724"/> base fragmentation on a layer 2 word which can be of any length. The default value is 8 and correspond 
to the default value for byte aligned layer 2. A value of 1 will indicate that there is no alignment and no need for padding.</t>
  <t>maximum-packet-size: defines the maximum size of a uncompressed datagram. By default, the value is set to 1280 bytes.</t>
</list></t>

<t>They are defined as unsigned integer, see <xref target="annexA"/>.</t>

</section>
</section>
</section>
<section anchor="rule-definition" title="Rule definition">

<t>A rule is idenfied by a unique rule identifier (rule ID) comprising both a Rule ID value and a Rule ID length. 
The YANG grouping rule-id-type defines the structure used to represent a rule ID. A length of 0 is allowed to represent an implicit rule.</t>

<t>Three types of rules are defined in <xref target="RFC8724"/>:</t>

<t><list style="symbols">
  <t>Compression: a compression rule is associated with the rule ID.</t>
  <t>No compression: this identifies the default rule used to send a packet in extenso when no compression rule was found (see <xref target="RFC8724"/> section 6).</t>
  <t>Fragmentation: fragmentation parameters are associated with the rule ID. Fragmentation is optional and feature “fragmentation” should be set.</t>
</list></t>

<figure title="Definition of a SCHC Context" anchor="Fig-yang-schc"><artwork><![CDATA[
  grouping rule-id-type {
    leaf rule-id-value {
      type uint32;
      description
        "Rule ID value, this value must be unique, considering its
         length.";
    }
    leaf rule-id-length {
      type uint8 {
        range "0..32";
      }
      description
        "Rule ID length, in bits. The value 0 is for implicit 
         rules.";
    }
    description
      "A rule ID is composed of a value and a length, expressed in
       bits.";
  }

  // SCHC table for a specific device.

  container schc {
    list rule {
      key "rule-id-value rule-id-length";
      uses rule-id-type;
      choice nature {
        case fragmentation {
          if-feature "fragmentation";
          uses fragmentation-content;
        }
        case compression {
          if-feature "compression";
          uses compression-content;
        }
        case no-compression {
          description
            "RFC8724 requires a rule for uncompressed headers.";
        }
        description
          "A rule is for compression, for no-compression or for
           fragmentation.";
      }
      description
        "Set of rules compression, no compression or fragmentation
         rules identified by their rule-id.";
    }
    description
      "a SCHC set of rules is composed of a list of rules which are
       used for compression, no-compression or fragmentation.";
  }
}
]]></artwork></figure>

<t>To access a specific rule, the rule ID length and value are used as a key. The rule is either
a compression or a fragmentation rule.</t>

<section anchor="compression-rule" title="Compression rule">

<t>A compression rule is composed of entries describing its processing (cf. <xref target="Fig-comp-entry"/>). An entry  contains all the information defined in <xref target="Fig-ctxt"/> with the types defined above.</t>

<t>The compression rule described <xref target="Fig-ctxt"/> is defined by compression-content. It defines a list of
compression-rule-entry, indexed by their field id, position and direction. The compression-rule-entry 
element represent a line of the table <xref target="Fig-ctxt"/>. Their type reflects the identifier types defined in
<xref target="comp_types"/></t>

<t>Some checks are performed on the values:</t>

<t><list style="symbols">
  <t>target value must be present for MO different from ignore.</t>
  <t>when MSB MO is specified, the matching-operator-value must be present</t>
</list></t>

<figure title="Definition of a compression entry" anchor="Fig-comp-entry"><artwork><![CDATA[
  grouping compression-rule-entry {
    description
      "These entries defines a compression entry (i.e. a line)
       as defined in RFC 8724.

+-------+--+--+--+------------+-----------------+---------------+
|Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|
+-------+--+--+--+------------+-----------------+---------------+

       An entry in a compression rule is composed of 7 elements:
       - Field ID: The header field to be compressed. The content 
         is a YANG identifer.
       - Field Length : either a positive integer of a function 
         defined as a YANG id.
       - Field Position: a positive (and possibly equal to 0) 
         integer.
       - Direction Indicator: a YANG identifier giving the direction.
       - Target value: a value against which the header Field is
         compared.
       - Matching Operator: a YANG id giving the operation, 
         parameters may be associated to that operator.
       - Comp./Decomp. Action: A YANG id giving the compression or
         decompression action, parameters may be associated to that
         action.
      ";
    leaf field-id {
      type schc:fid-type;
      mandatory true;
      description
        "Field ID, identify a field in the header with a YANG
         referenceid.";
    }
    leaf field-length {
      type schc:fl-type;
      mandatory true;
      description
        "Field Length, expressed in number of bits or through a 
         function defined as a YANG referenceid.";
    }
    leaf field-position {
      type uint8;
      mandatory true;
      description
        "Field position in the header is an integer. Position 1 
         matches the first occurence of a field in the header, 
         while incremented position values match subsequent 
         occurences.
         Position 0 means that this entry matches a field 
         irrespective of its position of occurence in the 
         header.
         Be aware that the decompressed header may have 
         position-0 fields ordered differently than they 
         appeared in the original packet.";
    }
    leaf direction-indicator {
      type schc:di-type;
      mandatory true;
      description
        "Direction Indicator, a YANG referenceid to say if the packet
         is bidirectional, up or down";
    }
    list target-value {
      key "index";
      uses tv-struct;
      description
        "A list of value to compare with the header field value.
         If target value is a singleton, position must be 0.
         For use as a matching list for the mo-match-mapping matching
         operator, positions should take consecutive values starting
         from 1.";
    }
    leaf matching-operator {
      type schc:mo-type;
      must
        "../target-value or derived-from-or-self(., 'mo-ignore')" {
        error-message
          "mo-equal, mo-msb and mo-match-mapping need target-value";
        description
          "target-value is not required for mo-ignore";
      }
      must "not (derived-from-or-self(., 'mo-msb')) or
            ../matching-operator-value" {
        error-message "mo-msb requires length value";
      }
      mandatory true;
      description
        "MO: Matching Operator";
    }
    list matching-operator-value {
      key "index";
      uses tv-struct;
      description
        "Matching Operator Arguments, based on TV structure to allow
         several arguments.
         In RFC 8724, only the MSB matching operator needs arguments 
         (a single argument, which is the number of most significant 
         bits to be matched)";
    }
    leaf comp-decomp-action {
      type schc:cda-type;
      mandatory true;
      description
        "CDA: Compression Decompression Action.";
    }
    list comp-decomp-action-value {
      key "index";
      uses tv-struct;
      description
        "CDA arguments, based on a TV structure, in order to allow 
         for several arguments. The CDAs specified in RFC 8724 
         require no argument.";
    }
  }

  grouping compression-content {
    list entry {
      key "field-id field-position direction-indicator";
      uses compression-rule-entry;
      description
        "A compression rule is a list of rule entries, each 
         describing a header field. An entry is identifed 
         through a field-id, its position in the packet and 
         its direction.";
    }
    description
      "Define a compression rule composed of a list of entries.";
  }
]]></artwork></figure>

</section>
<section anchor="fragmentation-rule" title="Fragmentation rule">

<t>A Fragmentation rule is composed of entries describing the protocol behavior. Some on them are numerical entries,
others are identifiers defined in <xref target="frag_types"/>.</t>

<t>The definition of a Fragmentation rule is divided into three sub-parts (cf. <xref target="Fig-frag-struct"/>):</t>

<t><list style="symbols">
  <t>parameters such as the fragmentation-mode, the l2-word-size and the direction. Since Fragmentation rules are always defined for a specific direction, the value must be either di-up or di-down (di-bidirectional is not allowed).</t>
  <t>parameters defining the Fragmentation header format (dtag-size, w-size, fcn-size and rcs-algorithm).</t>
  <t>Protocol parameters for timers (inactivity-timer, retransmission-timer). <xref target="RFC8724"/> do not specified any range for these timers. <xref target="RFC9011"/> recommends a duration of 12 hours. In fact, the value range sould be between milli-seconds for real time systems to several days. <xref target="Fig-timer-duration"/> shows the two parameters defined for timers:
  <list style="symbols">
      <t>the duration of a tick is computed through this formula 2^tick-duration/10^6. When tick-duration is set to 0, the unit is the micro-second. The default value of 20 leads to a unit of about 1.05 second. A value of 32 leads to a tick duration of about 1.19 hours.</t>
      <t>the number of ticks in the predefined unit. With the default tick-duration value of 20, the timers can cover a range between 1.0 sec and 19 hours covering <xref target="RFC9011"/> recommandation.</t>
    </list></t>
  <t>Protocol behavior (maximum-packet-size, max-interleaved-frames, max-ack-requests). If these parameters are specific to a single fragmentation mode, they are grouped in a structure dedicated to that Fragmentation mode. If some parameters can be found in several modes, typically ACK-Always and ACK-on-Error, they are defined in a common part and a when statement indicates which modes are allowed.</t>
</list></t>

<figure title="Timer duration values" anchor="Fig-timer-duration"><artwork><![CDATA[
  grouping timer-duration {
    leaf ticks-duration {
      type uint8;
      default "20";
      description
        "duration of one tick in micro-seconds:
            2^ticks-duration/10^6 = 1.048s";
    }
    leaf ticks-numbers {
      type uint16;
      description
        "timer duration = ticks-numbers * 2^ticks-duration / 10^6";
    }
    description
      "used by inactivity and retransmission timer. Allows a 
       precision from micro-second to year by sending the 
       tick-duration value. 
       For instance:

       tick-duration /  smallest value          highest value
       v
       20: 00y 000d 00h 00m 01s.048575<->00y 000d 19h 05m 18s.428159
       21: 00y 000d 00h 00m 02s.097151<->00y 001d 14h 10m 36s.856319
       22: 00y 000d 00h 00m 04s.194303<->00y 003d 04h 21m 13s.712639
       23: 00y 000d 00h 00m 08s.388607<->00y 006d 08h 42m 27s.425279
       24: 00y 000d 00h 00m 16s.777215<->00y 012d 17h 24m 54s.850559
       25: 00y 000d 00h 00m 33s.554431<->00y 025d 10h 49m 49s.701119
       
       Note that the smallest value is also the incrementation step, 
       so the timer precision.
      ";
  }
]]></artwork></figure>

<figure title="Fragmentation Parameters" anchor="Fig-frag-struct"><artwork><![CDATA[
  grouping fragmentation-content {
    description
      "This grouping defines the fragmentation parameters for
       all the modes (No-Ack, Ack-Always and Ack-on-Error) specified 
       in RFC 8724.";
    leaf fragmentation-mode {
      type schc:fragmentation-mode-type;
      mandatory true;
      description
        "which fragmentation mode is used (noAck, AckAlways,
         AckonError)";
    }
    leaf l2-word-size {
      type uint8;
      default "8";
      description
        "Size, in bits, of the layer 2 word";
    }
    leaf direction {
      type schc:di-type;
      must "derived-from-or-self(., 'di-up') or
            derived-from-or-self(., 'di-down')" {
        error-message
          "direction for fragmentation rules are up or down.";
      }
      mandatory true;
      description
        "Should be up or down, bidirectionnal is forbiden.";
    }
    // SCHC Frag header format 
    leaf dtag-size {
      type uint8;
      default "0";
      description
        "Size, in bits, of the DTag field (T variable from 
         RFC8724).";
    }
    leaf w-size {
      when "derived-from(../fragmentation-mode,
                                'fragmentation-mode-ack-on-error')
            or
            derived-from(../fragmentation-mode,
                                'fragmentation-mode-ack-always') ";
      type uint8;
      description
        "Size, in bits, of the window field (M variable from 
         RFC8724).";
    }
    leaf fcn-size {
      type uint8;
      mandatory true;
      description
        "Size, in bits, of the FCN field (N variable from RFC8724).";
    }
    leaf rcs-algorithm {
      type rcs-algorithm-type;
      default "schc:rcs-RFC8724";
      description
        "Algorithm used for RCS. The algorithm specifies the RCS 
         size";
    }
    // SCHC fragmentation protocol parameters
    leaf maximum-packet-size {
      type uint16;
      default "1280";
      description
        "When decompression is done, packet size must not
         strictly exceed this limit, expressed in bytes.";
    }
    leaf window-size {
      type uint16;
      description
        "By default, if not specified 2^w-size - 1. Should not exceed
         this value. Possible FCN values are between 0 and
         window-size - 1.";
    }
    leaf max-interleaved-frames {
      type uint8;
      default "1";
      description
        "Maximum of simultaneously fragmented frames. Maximum value 
         is 2^dtag-size. All DTAG values can be used, but at most
         max-interleaved-frames must be active at any time.";
    }
    container inactivity-timer {
      uses timer-duration;
      description
        "Duration is seconds of the inactivity timer, 0 indicates
         that the timer is disabled.";
    }
    container retransmission-timer {
      uses timer-duration;
      when "derived-from(../fragmentation-mode,
                                'fragmentation-mode-ack-on-error')
            or
            derived-from(../fragmentation-mode,
                                'fragmentation-mode-ack-always') ";
      description
        "Duration in seconds of the retransmission timer.";
    }
    leaf max-ack-requests {
      when "derived-from(../fragmentation-mode,
                                'fragmentation-mode-ack-on-error')
            or
            derived-from(../fragmentation-mode,
                                'fragmentation-mode-ack-always') ";
      type uint8 {
        range "1..max";
      }
      description
        "The maximum number of retries for a specific SCHC ACK.";
    }
    choice mode {
      case no-ack;
      case ack-always;
      case ack-on-error {
        leaf tile-size {
          when "derived-from(../fragmentation-mode,
                             'fragmentation-mode-ack-on-error')";
          type uint8;
          description
            "Size, in bits, of tiles. If not specified or set to 0,
             tiles fill the fragment.";
        }
        leaf tile-in-All1 {
          when "derived-from(../fragmentation-mode,
                             'fragmentation-mode-ack-on-error')";
          type schc:all1-data-type;
          description
            "Defines whether the sender and receiver expect a tile in
             All-1 fragments or not, or if it is left to the sender's
             choice.";
        }
        leaf ack-behavior {
          when "derived-from(../fragmentation-mode,
                             'fragmentation-mode-ack-on-error')";
          type schc:ack-behavior-type;
          description
            "Sender behavior to acknowledge, after All-0, All-1 or
             when the LPWAN allows it.";
        }
      }
      description
        "RFC 8724 defines 3 fragmentation modes.";
    }
  }
]]></artwork></figure>

</section>
<section anchor="yang-tree" title="YANG Tree">

<figure anchor="Fig-model-overview"><artwork><![CDATA[
module: ietf-schc
 +-rw schc
   +-rw rule* [rule-id-value rule-id-length]
      +-rw rule-id-value                   uint32
      +-rw rule-id-length                  uint8
      +-rw (nature)?
        +-:(fragmentation) {fragmentation}?
        | +--rw fragmentation-mode        schc:fragmentation-mode-type
        | +--rw l2-word-size?             uint8
        | +--rw direction                 schc:di-type
        | +--rw dtag-size?                uint8
        | +--rw w-size?                   uint8
        | +--rw fcn-size                  uint8
        | +--rw rcs-algorithm?            rcs-algorithm-type
        | +--rw maximum-packet-size?      uint16
        | +--rw window-size?              uint16
        | +--rw max-interleaved-frames?   uint8
        | +--rw inactivity-timer
        | |  +--rw ticks-duration?   uint8
        | |  +--rw ticks-numbers?    uint16
        | +--rw retransmission-timer
        | |  +--rw ticks-duration?   uint8
        | |  +--rw ticks-numbers?    uint16
        | +--rw max-ack-requests?         uint8
        | +--rw (mode)?
        |    +--:(no-ack)
        |    +--:(ack-always)
        |    +--:(ack-on-error)
        |       +--rw tile-size?          uint8
        |       +--rw tile-in-All1?       schc:all1-data-type
        |       +--rw ack-behavior?       schc:ack-behavior-type
        +-:(compression) {compression}?
        | +--rw entry* [field-id field-position direction-indicator]
        |    +--rw field-id                    schc:fid-type
        |    +--rw field-length                schc:fl-type
        |    +--rw field-position              uint8
        |    +--rw direction-indicator         schc:di-type
        |    +--rw target-value* [index]
        |    |  +--rw value?   binary
        |    |  +--rw index    uint16
        |    +--rw matching-operator           schc:mo-type
        |    +--rw matching-operator-value* [index]
        |    |  +--rw value?   binary
        |    |  +--rw index    uint16
        |    +--rw comp-decomp-action          schc:cda-type
        |    +--rw comp-decomp-action-value* [index]
        |       +--rw value?   binary
        |       +--rw index    uint16
        +-:(no-compression)
]]></artwork></figure>

</section>
</section>
<section anchor="implementation-status" title="Implementation Status">

<t>This section records the status of known implementations of the
protocol defined by this specification at the time of posting of
this Internet-Draft, and is based on a proposal described in
<xref target="RFC7942"/>.  The description of implementations in this section is
intended to assist the IETF in its decision processes in
progressing drafts to RFCs.  Please note that the listing of any
individual implementation here does not imply endorsement by the
IETF.  Furthermore, no effort has been spent to verify the
information presented here that was supplied by IETF contributors.
This is not intended as, and must not be construed to be, a
catalog of available implementations or their features.  Readers
are advised to note that other implementations may exist.</t>

<t>According to <xref target="RFC7942"/>, “this will allow reviewers and working
groups to assign due consideration to documents that have the
benefit of running code, which may serve as evidence of valuable
experimentation and feedback that have made the implemented
protocols more mature.  It is up to the individual working groups
to use this information as they see fit”.</t>

<t><list style="symbols">
  <t>Openschc is implementing the conversion between the local rule 
representation and the representation conform to the Data Model 
in JSON and CBOR (following -08 draft).</t>
</list></t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>This document has no request to IANA.</t>

</section>
<section anchor="SecConsiderations" title="Security considerations">

<t>This document does not have any more Security consideration than the ones already raised in <xref target="RFC8724"/> and <xref target="RFC8824"/>.</t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>The authors would like to thank Dominique Barthel, Carsten Bormann, Alexander Pelov for their careful reading and valuable inputs. A special thanks for 
Carl Moberg for his patience and wise advices when building the model.</t>

</section>
<section anchor="annexA" title="YANG Module">

<figure anchor="Fig-schc"><artwork><![CDATA[
<code begins> file ietf-schc@2022-02-15.yang
module ietf-schc {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-schc";
  prefix schc;

  organization
    "IETF IPv6 over Low Power Wide-Area Networks (lpwan) working 
     group";
  contact
    "WG Web:   <https://datatracker.ietf.org/wg/lpwan/about/>
     WG List:  <mailto:p-wan@ietf.org>
     Editor:   Laurent Toutain
       <mailto:laurent.toutain@imt-atlantique.fr>
     Editor:   Ana Minaburo
       <mailto:ana@ackl.io>";
  description
    "
     Copyright (c) 2021 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX
     (https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
     for full legal notices.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
     'MAY', and 'OPTIONAL' in this document are to be interpreted as
     described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
     they appear in all capitals, as shown here.

     ***************************************************************

     Generic Data model for Static Context Header Compression Rule 
     for SCHC, based on RFC 8724 and RFC8824. Include compression, 
     no compression and fragmentation rules.

     This module is a YANG model for SCHC rules (RFC 8724 and 
     RFC8824). RFC 8724 describes compression rules in a abstract 
     way through a table.

  |-----------------------------------------------------------------|
  |  (FID)            Rule 1                                        |
  |+-------+--+--+--+------------+-----------------+---------------+|
  ||Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||
  |+-------+--+--+--+------------+-----------------+---------------+|
  ||Field 2|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||
  |+-------+--+--+--+------------+-----------------+---------------+|
  ||...    |..|..|..|   ...      | ...             | ...           ||
  |+-------+--+--+--+------------+-----------------+---------------+|
  ||Field N|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act||
  |+-------+--+--+--+------------+-----------------+---------------+|
  |-----------------------------------------------------------------|

     This module proposes a global data model that can be used for 
     rule exchanges or modification. It proposes both the data model 
     format and the global identifiers used to describe some 
     operations in fields.
     This data model applies to both compression and fragmentation.";

  revision 2022-02-15 {
    description
      "Initial version from RFC XXXX ";
    reference
      "RFC XXX: Data Model for Static Context Header Compression
       (SCHC)";
  }

  feature compression {
    description
      "SCHC compression capabilities are taken into account";
  }

  feature fragmentation {
    description
      "SCHC fragmentation capabilities are taken into account";
  }

  // -------------------------
  //  Field ID type definition
  //--------------------------
  // generic value TV definition 

  identity fid-base-type {
    description
      "Field ID base type for all fields";
  }

  identity fid-ipv6-base-type {
    base fid-base-type;
    description
      "Field ID base type for IPv6 headers described in RFC 8200";
  }

  identity fid-ipv6-version {
    base fid-ipv6-base-type;
    description
      "IPv6 version field from RFC8200";
  }

  identity fid-ipv6-trafficclass {
    base fid-ipv6-base-type;
    description
      "IPv6 Traffic Class field from RFC8200";
  }

  identity fid-ipv6-trafficclass-ds {
    base fid-ipv6-trafficclass;
    description
      "IPv6 Traffic Class field from RFC8200,
       DiffServ field from RFC3168";
  }

  identity fid-ipv6-trafficclass-ecn {
    base fid-ipv6-trafficclass;
    description
      "IPv6 Traffic Class field from RFC8200,
       ECN field from RFC3168";
  }

  identity fid-ipv6-flowlabel {
    base fid-ipv6-base-type;
    description
      "IPv6 Flow Label field from RFC8200";
  }

  identity fid-ipv6-payloadlength {
    base fid-ipv6-base-type;
    description
      "IPv6 Payload Length field from RFC8200";
  }

  identity fid-ipv6-nextheader {
    base fid-ipv6-base-type;
    description
      "IPv6 Next Header field from RFC8200";
  }

  identity fid-ipv6-hoplimit {
    base fid-ipv6-base-type;
    description
      "IPv6 Next Header field from RFC8200";
  }

  identity fid-ipv6-devprefix {
    base fid-ipv6-base-type;
    description
      "corresponds to either the source address or the destination
              address prefix of RFC 8200. Depending if it is
              respectively an uplink or a downlink message.";
  }

  identity fid-ipv6-deviid {
    base fid-ipv6-base-type;
    description
      "corresponds to either the source address or the destination
       address prefix of RFC 8200. Depending if it is respectively
       an uplink or a downlink message.";
  }

  identity fid-ipv6-appprefix {
    base fid-ipv6-base-type;
    description
      "corresponds to either the source address or the destination
       address prefix of RFC 8200. Depending if it is respectively
       a downlink or an uplink message.";
  }

  identity fid-ipv6-appiid {
    base fid-ipv6-base-type;
    description
      "corresponds to either the source address or the destination
       address prefix of RFC 8200. Depending if it is respectively
       a downlink or an uplink message.";
  }

  identity fid-udp-base-type {
    base fid-base-type;
    description
      "Field ID base type for UDP headers described in RFC 768";
  }

  identity fid-udp-dev-port {
    base fid-udp-base-type;
    description
      "UDP source or destination port from RFC 768, if uplink or
       downlink communication, respectively.";
  }

  identity fid-udp-app-port {
    base fid-udp-base-type;
    description
      "UDP destination or source port from RFC 768, if uplink or
       downlink communication, respectively.";
  }

  identity fid-udp-length {
    base fid-udp-base-type;
    description
      "UDP length from RFC 768";
  }

  identity fid-udp-checksum {
    base fid-udp-base-type;
    description
      "UDP length from RFC 768";
  }

  identity fid-coap-base-type {
    base fid-base-type;
    description
      "Field ID base type for UDP headers described in RFC 7252";
  }

  identity fid-coap-version {
    base fid-coap-base-type;
    description
      "CoAP version from RFC 7252";
  }

  identity fid-coap-type {
    base fid-coap-base-type;
    description
      "CoAP type from RFC 7252";
  }

  identity fid-coap-tkl {
    base fid-coap-base-type;
    description
      "CoAP token length from RFC 7252";
  }

  identity fid-coap-code {
    base fid-coap-base-type;
    description
      "CoAP code from RFC 7252";
  }

  identity fid-coap-code-class {
    base fid-coap-code;
    description
      "CoAP code class from RFC 7252";
  }

  identity fid-coap-code-detail {
    base fid-coap-code;
    description
      "CoAP code detail from RFC 7252";
  }

  identity fid-coap-mid {
    base fid-coap-base-type;
    description
      "CoAP message ID from RFC 7252";
  }

  identity fid-coap-token {
    base fid-coap-base-type;
    description
      "CoAP token from RFC 7252";
  }

  identity fid-coap-option-if-match {
    base fid-coap-base-type;
    description
      "CoAP option If-Match from RFC 7252";
  }

  identity fid-coap-option-uri-host {
    base fid-coap-base-type;
    description
      "CoAP option URI-Host from RFC 7252";
  }

  identity fid-coap-option-etag {
    base fid-coap-base-type;
    description
      "CoAP option Etag from RFC 7252";
  }

  identity fid-coap-option-if-none-match {
    base fid-coap-base-type;
    description
      "CoAP option if-none-match from RFC 7252";
  }

  identity fid-coap-option-observe {
    base fid-coap-base-type;
    description
      "CoAP option Observe from RFC 7641";
  }

  identity fid-coap-option-uri-port {
    base fid-coap-base-type;
    description
      "CoAP option Uri-Port from RFC 7252";
  }

  identity fid-coap-option-location-path {
    base fid-coap-base-type;
    description
      "CoAP option Location-Path from RFC 7252";
  }

  identity fid-coap-option-uri-path {
    base fid-coap-base-type;
    description
      "CoAP option Uri-Path from RFC 7252";
  }

  identity fid-coap-option-content-format {
    base fid-coap-base-type;
    description
      "CoAP option Content Format from RFC 7252";
  }

  identity fid-coap-option-max-age {
    base fid-coap-base-type;
    description
      "CoAP option Max-Age from RFC 7252";
  }

  identity fid-coap-option-uri-query {
    base fid-coap-base-type;
    description
      "CoAP option Uri-Query from RFC 7252";
  }

  identity fid-coap-option-accept {
    base fid-coap-base-type;
    description
      "CoAP option Accept from RFC 7252";
  }

  identity fid-coap-option-location-query {
    base fid-coap-base-type;
    description
      "CoAP option Location-Query from RFC 7252";
  }

  identity fid-coap-option-block2 {
    base fid-coap-base-type;
    description
      "CoAP option Block2 from RFC 7959";
  }

  identity fid-coap-option-block1 {
    base fid-coap-base-type;
    description
      "CoAP option Block1 from RFC 7959";
  }

  identity fid-coap-option-size2 {
    base fid-coap-base-type;
    description
      "CoAP option size2 from RFC 7959";
  }

  identity fid-coap-option-proxy-uri {
    base fid-coap-base-type;
    description
      "CoAP option Proxy-Uri from RFC 7252";
  }

  identity fid-coap-option-proxy-scheme {
    base fid-coap-base-type;
    description
      "CoAP option Proxy-scheme from RFC 7252";
  }

  identity fid-coap-option-size1 {
    base fid-coap-base-type;
    description
      "CoAP option Size1 from RFC 7252";
  }

  identity fid-coap-option-no-response {
    base fid-coap-base-type;
    description
      "CoAP option No response from RFC 7967";
  }

  identity fid-coap-option-oscore-flags {
    base fid-coap-base-type;
    description
      "CoAP option oscore flags (see RFC 8824, section 6.4)";
  }

  identity fid-coap-option-oscore-piv {
    base fid-coap-base-type;
    description
      "CoAP option oscore flags (see RFC 8824, section 6.4)";
  }

  identity fid-coap-option-oscore-kid {
    base fid-coap-base-type;
    description
      "CoAP option oscore flags (see RFC 8824, section 6.4)";
  }

  identity fid-coap-option-oscore-kidctx {
    base fid-coap-base-type;
    description
      "CoAP option oscore flags (see RFC 8824, section 6.4)";
  }

  //----------------------------------
  // Field Length type definition
  //----------------------------------

  identity fl-base-type {
    description
      "Used to extend field length functions.";
  }

  identity fl-variable {
    base fl-base-type;
    description
      "Residue length in Byte is sent as defined
       for CoAP in RFC 8824 (cf. 5.3).";
  }

  identity fl-token-length {
    base fl-base-type;
    description
      "Residue length in Byte is sent as defined
       for CoAP in RFC 8824 (cf. 4.5).";
  }

  //---------------------------------
  // Direction Indicator type
  //---------------------------------

  identity di-base-type {
    description
      "Used to extend direction indicators.";
  }

  identity di-bidirectional {
    base di-base-type;
    description
      "Direction Indication of bidirectionality in
       RFC 8724 (cf. 7.1).";
  }

  identity di-up {
    base di-base-type;
    description
      "Direction Indication of uplink defined in
       RFC 8724 (cf. 7.1).";
  }

  identity di-down {
    base di-base-type;
    description
      "Direction Indication of downlink defined in
       RFC 8724 (cf. 7.1).";
  }

  //----------------------------------
  // Matching Operator type definition
  //----------------------------------

  identity mo-base-type {
    description
      "Used to extend Matching Operators with SID values";
  }

  identity mo-equal {
    base mo-base-type;
    description
      "Equal MO as defined in RFC 8724 (cf. 7.3)";
  }

  identity mo-ignore {
    base mo-base-type;
    description
      "Ignore MO as defined in RFC 8724 (cf. 7.3)";
  }

  identity mo-msb {
    base mo-base-type;
    description
      "MSB MO as defined in RFC 8724 (cf. 7.3)";
  }

  identity mo-match-mapping {
    base mo-base-type;
    description
      "match-mapping MO as defined in RFC 8724 (cf. 7.3)";
  }

  //------------------------------
  // CDA type definition
  //------------------------------

  identity cda-base-type {
    description
      "Compression Decompression Actions.";
  }

  identity cda-not-sent {
    base cda-base-type;
    description
      "not-sent CDA as defined in RFC 8724 (cf. 7.4).";
  }

  identity cda-value-sent {
    base cda-base-type;
    description
      "value-sent CDA as defined in RFC 8724 (cf. 7.4).";
  }

  identity cda-lsb {
    base cda-base-type;
    description
      "LSB CDA as defined in RFC 8724 (cf. 7.4).";
  }

  identity cda-mapping-sent {
    base cda-base-type;
    description
      "mapping-sent CDA as defined in RFC 8724 (cf. 7.4).";
  }

  identity cda-compute {
    base cda-base-type;
    description
      "compute-* CDA as defined in RFC 8724 (cf. 7.4)";
  }

  identity cda-deviid {
    base cda-base-type;
    description
      "deviid CDA as defined in RFC 8724 (cf. 7.4)";
  }

  identity cda-appiid {
    base cda-base-type;
    description
      "appiid CDA as defined in RFC 8724 (cf. 7.4)";
  }

  // -- type definition

  typedef fid-type {
    type identityref {
      base fid-base-type;
    }
    description
      "Field ID generic type.";
  }

  typedef fl-type {
    type union {
      type int64; /* positive integer, expressing length in bits */
      type identityref { /* function */
        base fl-base-type;
      }
    }
    description
      "Field length either a positive integer expressing the size in
       bits or a function defined through an identityref.";
  }

  typedef di-type {
    type identityref {
      base di-base-type;
    }
    description
      "Direction in LPWAN network, up when emitted by the device,
       down when received by the device, bi when emitted or
       received by the device.";
  }

  typedef mo-type {
    type identityref {
      base mo-base-type;
    }
    description
      "Matching Operator (MO) to compare fields values with
       target values";
  }

  typedef cda-type {
    type identityref {
      base cda-base-type;
    }
    description
      "Compression Decompression Action to compression or
       decompress a field.";
  }

  // -- FRAGMENTATION TYPE
  // -- fragmentation modes

  identity fragmentation-mode-base-type {
    description
      "fragmentation mode.";
  }

  identity fragmentation-mode-no-ack {
    base fragmentation-mode-base-type;
    description
      "No-ACK of RFC8724.";
  }

  identity fragmentation-mode-ack-always {
    base fragmentation-mode-base-type;
    description
      "ACK-Always of RFC8724.";
  }

  identity fragmentation-mode-ack-on-error {
    base fragmentation-mode-base-type;
    description
      "ACK-on-Error of RFC8724.";
  }

  typedef fragmentation-mode-type {
    type identityref {
      base fragmentation-mode-base-type;
    }
    description
      "type used in rules";
  }

  // -- Ack behavior 

  identity ack-behavior-base-type {
    description
      "Define when to send an Acknowledgment .";
  }

  identity ack-behavior-after-All0 {
    base ack-behavior-base-type;
    description
      "Fragmentation expects Ack after sending All0 fragment.";
  }

  identity ack-behavior-after-All1 {
    base ack-behavior-base-type;
    description
      "Fragmentation expects Ack after sending All1 fragment.";
  }

  identity ack-behavior-by-layer2 {
    base ack-behavior-base-type;
    description
      "Layer 2 defines when to send an Ack.";
  }

  typedef ack-behavior-type {
    type identityref {
      base ack-behavior-base-type;
    }
    description
      "Type used in rules.";
  }

  // -- All1 with data types

  identity all1-data-base-type {
    description
      "Type to define when to send an Acknowledgment message.";
  }

  identity all1-data-no {
    base all1-data-base-type;
    description
      "All1 contains no tiles.";
  }

  identity all1-data-yes {
    base all1-data-base-type;
    description
      "All1 MUST contain a tile.";
  }

  identity all1-data-sender-choice {
    base all1-data-base-type;
    description
      "Fragmentation process chooses to send tiles or not in all1.";
  }

  typedef all1-data-type {
    type identityref {
      base all1-data-base-type;
    }
    description
      "Type used in rules.";
  }

  // -- RCS algorithm types

  identity rcs-algorithm-base-type {
    description
      "Identify which algorithm is used to compute RCS.
       The algorithm also defines the size of the RCS field.";
  }

  identity rcs-RFC8724 {
    base rcs-algorithm-base-type;
    description
      "CRC 32 defined as default RCS in RFC8724. RCS is 4 byte-long";
  }

  typedef rcs-algorithm-type {
    type identityref {
      base rcs-algorithm-base-type;
    }
    description
      "type used in rules.";
  }

  // --------- TIMER DURATION -------------------

  grouping timer-duration {
    leaf ticks-duration {
      type uint8;
      default "20";
      description
        "duration of one tick in micro-seconds:
            2^ticks-duration/10^6 = 1.048s";
    }
    leaf ticks-numbers {
      type uint16;
      description
        "timer duration = ticks-numbers * 2^ticks-duration / 10^6";
    }
    description
      "used by inactivity and retransmission timer. Allows a 
       precision from micro-second to year by sending the 
       tick-duration value. 
       For instance:

       tick-duration /  smallest value          highest value
       v
       20: 00y 000d 00h 00m 01s.048575<->00y 000d 19h 05m 18s.428159
       21: 00y 000d 00h 00m 02s.097151<->00y 001d 14h 10m 36s.856319
       22: 00y 000d 00h 00m 04s.194303<->00y 003d 04h 21m 13s.712639
       23: 00y 000d 00h 00m 08s.388607<->00y 006d 08h 42m 27s.425279
       24: 00y 000d 00h 00m 16s.777215<->00y 012d 17h 24m 54s.850559
       25: 00y 000d 00h 00m 33s.554431<->00y 025d 10h 49m 49s.701119
       
       Note that the smallest value is also the incrementation step, 
       so the timer precision.
      ";
  }

  // --------  RULE ENTRY DEFINITION ------------

  grouping tv-struct {
    description
      "Defines the target value element. Always a binary type, 
       strings must be converted to binary. field-id allows the 
       conversion to the appropriate type.";
    leaf value {
      type binary;
      description
        "Target Value";
    }
    leaf index {
      type uint16;
      description
        "Index gives the position in the matching-list. If only one
         element is present, index is 0. Otherwise, indicia is the
         the order in the matching list, starting at 0.";
    }
  }

  grouping compression-rule-entry {
    description
      "These entries defines a compression entry (i.e. a line)
       as defined in RFC 8724.

+-------+--+--+--+------------+-----------------+---------------+
|Field 1|FL|FP|DI|Target Value|Matching Operator|Comp/Decomp Act|
+-------+--+--+--+------------+-----------------+---------------+

       An entry in a compression rule is composed of 7 elements:
       - Field ID: The header field to be compressed. The content 
         is a YANG identifer.
       - Field Length : either a positive integer of a function 
         defined as a YANG id.
       - Field Position: a positive (and possibly equal to 0) 
         integer.
       - Direction Indicator: a YANG identifier giving the direction.
       - Target value: a value against which the header Field is
         compared.
       - Matching Operator: a YANG id giving the operation, 
         parameters may be associated to that operator.
       - Comp./Decomp. Action: A YANG id giving the compression or
         decompression action, parameters may be associated to that
         action.
      ";
    leaf field-id {
      type schc:fid-type;
      mandatory true;
      description
        "Field ID, identify a field in the header with a YANG
         referenceid.";
    }
    leaf field-length {
      type schc:fl-type;
      mandatory true;
      description
        "Field Length, expressed in number of bits or through a 
         function defined as a YANG referenceid.";
    }
    leaf field-position {
      type uint8;
      mandatory true;
      description
        "Field position in the header is an integer. Position 1 
         matches the first occurence of a field in the header, 
         while incremented position values match subsequent 
         occurences.
         Position 0 means that this entry matches a field 
         irrespective of its position of occurence in the 
         header.
         Be aware that the decompressed header may have 
         position-0 fields ordered differently than they 
         appeared in the original packet.";
    }
    leaf direction-indicator {
      type schc:di-type;
      mandatory true;
      description
        "Direction Indicator, a YANG referenceid to say if the packet
         is bidirectional, up or down";
    }
    list target-value {
      key "index";
      uses tv-struct;
      description
        "A list of value to compare with the header field value.
         If target value is a singleton, position must be 0.
         For use as a matching list for the mo-match-mapping matching
         operator, positions should take consecutive values starting
         from 1.";
    }
    leaf matching-operator {
      type schc:mo-type;
      must
        "../target-value or derived-from-or-self(., 'mo-ignore')" {
        error-message
          "mo-equal, mo-msb and mo-match-mapping need target-value";
        description
          "target-value is not required for mo-ignore";
      }
      must "not (derived-from-or-self(., 'mo-msb')) or
            ../matching-operator-value" {
        error-message "mo-msb requires length value";
      }
      mandatory true;
      description
        "MO: Matching Operator";
    }
    list matching-operator-value {
      key "index";
      uses tv-struct;
      description
        "Matching Operator Arguments, based on TV structure to allow
         several arguments.
         In RFC 8724, only the MSB matching operator needs arguments 
         (a single argument, which is the number of most significant 
         bits to be matched)";
    }
    leaf comp-decomp-action {
      type schc:cda-type;
      mandatory true;
      description
        "CDA: Compression Decompression Action.";
    }
    list comp-decomp-action-value {
      key "index";
      uses tv-struct;
      description
        "CDA arguments, based on a TV structure, in order to allow 
         for several arguments. The CDAs specified in RFC 8724 
         require no argument.";
    }
  }

  grouping compression-content {
    list entry {
      key "field-id field-position direction-indicator";
      uses compression-rule-entry;
      description
        "A compression rule is a list of rule entries, each 
         describing a header field. An entry is identifed 
         through a field-id, its position in the packet and 
         its direction.";
    }
    description
      "Define a compression rule composed of a list of entries.";
  }

  grouping fragmentation-content {
    description
      "This grouping defines the fragmentation parameters for
       all the modes (No-Ack, Ack-Always and Ack-on-Error) specified 
       in RFC 8724.";
    leaf fragmentation-mode {
      type schc:fragmentation-mode-type;
      mandatory true;
      description
        "which fragmentation mode is used (noAck, AckAlways,
         AckonError)";
    }
    leaf l2-word-size {
      type uint8;
      default "8";
      description
        "Size, in bits, of the layer 2 word";
    }
    leaf direction {
      type schc:di-type;
      must "derived-from-or-self(., 'di-up') or
            derived-from-or-self(., 'di-down')" {
        error-message
          "direction for fragmentation rules are up or down.";
      }
      mandatory true;
      description
        "Should be up or down, bidirectionnal is forbiden.";
    }
    // SCHC Frag header format 
    leaf dtag-size {
      type uint8;
      default "0";
      description
        "Size, in bits, of the DTag field (T variable from 
         RFC8724).";
    }
    leaf w-size {
      when "derived-from(../fragmentation-mode,
                                'fragmentation-mode-ack-on-error')
            or
            derived-from(../fragmentation-mode,
                                'fragmentation-mode-ack-always') ";
      type uint8;
      description
        "Size, in bits, of the window field (M variable from 
         RFC8724).";
    }
    leaf fcn-size {
      type uint8;
      mandatory true;
      description
        "Size, in bits, of the FCN field (N variable from RFC8724).";
    }
    leaf rcs-algorithm {
      type rcs-algorithm-type;
      default "schc:rcs-RFC8724";
      description
        "Algorithm used for RCS. The algorithm specifies the RCS 
         size";
    }
    // SCHC fragmentation protocol parameters
    leaf maximum-packet-size {
      type uint16;
      default "1280";
      description
        "When decompression is done, packet size must not
         strictly exceed this limit, expressed in bytes.";
    }
    leaf window-size {
      type uint16;
      description
        "By default, if not specified 2^w-size - 1. Should not exceed
         this value. Possible FCN values are between 0 and
         window-size - 1.";
    }
    leaf max-interleaved-frames {
      type uint8;
      default "1";
      description
        "Maximum of simultaneously fragmented frames. Maximum value 
         is 2^dtag-size. All DTAG values can be used, but at most
         max-interleaved-frames must be active at any time.";
    }
    container inactivity-timer {
      uses timer-duration;
      description
        "Duration is seconds of the inactivity timer, 0 indicates
         that the timer is disabled.";
    }
    container retransmission-timer {
      uses timer-duration;
      when "derived-from(../fragmentation-mode,
                                'fragmentation-mode-ack-on-error')
            or
            derived-from(../fragmentation-mode,
                                'fragmentation-mode-ack-always') ";
      description
        "Duration in seconds of the retransmission timer.";
    }
    leaf max-ack-requests {
      when "derived-from(../fragmentation-mode,
                                'fragmentation-mode-ack-on-error')
            or
            derived-from(../fragmentation-mode,
                                'fragmentation-mode-ack-always') ";
      type uint8 {
        range "1..max";
      }
      description
        "The maximum number of retries for a specific SCHC ACK.";
    }
    choice mode {
      case no-ack;
      case ack-always;
      case ack-on-error {
        leaf tile-size {
          when "derived-from(../fragmentation-mode,
                             'fragmentation-mode-ack-on-error')";
          type uint8;
          description
            "Size, in bits, of tiles. If not specified or set to 0,
             tiles fill the fragment.";
        }
        leaf tile-in-All1 {
          when "derived-from(../fragmentation-mode,
                             'fragmentation-mode-ack-on-error')";
          type schc:all1-data-type;
          description
            "Defines whether the sender and receiver expect a tile in
             All-1 fragments or not, or if it is left to the sender's
             choice.";
        }
        leaf ack-behavior {
          when "derived-from(../fragmentation-mode,
                             'fragmentation-mode-ack-on-error')";
          type schc:ack-behavior-type;
          description
            "Sender behavior to acknowledge, after All-0, All-1 or
             when the LPWAN allows it.";
        }
      }
      description
        "RFC 8724 defines 3 fragmentation modes.";
    }
  }

  // Define rule ID. Rule ID is composed of a RuleID value and a 
  // Rule ID Length

  grouping rule-id-type {
    leaf rule-id-value {
      type uint32;
      description
        "Rule ID value, this value must be unique, considering its
         length.";
    }
    leaf rule-id-length {
      type uint8 {
        range "0..32";
      }
      description
        "Rule ID length, in bits. The value 0 is for implicit 
         rules.";
    }
    description
      "A rule ID is composed of a value and a length, expressed in
       bits.";
  }

  // SCHC table for a specific device.

  container schc {
    list rule {
      key "rule-id-value rule-id-length";
      uses rule-id-type;
      choice nature {
        case fragmentation {
          if-feature "fragmentation";
          uses fragmentation-content;
        }
        case compression {
          if-feature "compression";
          uses compression-content;
        }
        case no-compression {
          description
            "RFC8724 requires a rule for uncompressed headers.";
        }
        description
          "A rule is for compression, for no-compression or for
           fragmentation.";
      }
      description
        "Set of rules compression, no compression or fragmentation
         rules identified by their rule-id.";
    }
    description
      "a SCHC set of rules is composed of a list of rules which are
       used for compression, no-compression or fragmentation.";
  }
}
<code ends>
]]></artwork></figure>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC8724" target='https://www.rfc-editor.org/info/rfc8724'>
<front>
<title>SCHC: Generic Framework for Static Context Header Compression and Fragmentation</title>
<author initials='A.' surname='Minaburo' fullname='A. Minaburo'><organization /></author>
<author initials='L.' surname='Toutain' fullname='L. Toutain'><organization /></author>
<author initials='C.' surname='Gomez' fullname='C. Gomez'><organization /></author>
<author initials='D.' surname='Barthel' fullname='D. Barthel'><organization /></author>
<author initials='JC.' surname='Zuniga' fullname='JC. Zuniga'><organization /></author>
<date year='2020' month='April' />
<abstract><t>This document defines the Static Context Header Compression and fragmentation (SCHC) framework, which provides both a header compression mechanism and an optional fragmentation mechanism. SCHC has been designed with Low-Power Wide Area Networks (LPWANs) in mind.</t><t>SCHC compression is based on a common static context stored both in the LPWAN device and in the network infrastructure side. This document defines a generic header compression mechanism and its application to compress IPv6/UDP headers.</t><t>This document also specifies an optional fragmentation and reassembly mechanism. It can be used to support the IPv6 MTU requirement over the LPWAN technologies. Fragmentation is needed for IPv6 datagrams that, after SCHC compression or when such compression was not possible, still exceed the Layer 2 maximum payload size.</t><t>The SCHC header compression and fragmentation mechanisms are independent of the specific LPWAN technology over which they are used. This document defines generic functionalities and offers flexibility with regard to parameter settings and mechanism choices. This document standardizes the exchange over the LPWAN between two SCHC entities. Settings and choices specific to a technology or a product are expected to be grouped into profiles, which are specified in other documents. Data models for the context and profiles are out of scope.</t></abstract>
</front>
<seriesInfo name='RFC' value='8724'/>
<seriesInfo name='DOI' value='10.17487/RFC8724'/>
</reference>



<reference  anchor="RFC8824" target='https://www.rfc-editor.org/info/rfc8824'>
<front>
<title>Static Context Header Compression (SCHC) for the Constrained Application Protocol (CoAP)</title>
<author initials='A.' surname='Minaburo' fullname='A. Minaburo'><organization /></author>
<author initials='L.' surname='Toutain' fullname='L. Toutain'><organization /></author>
<author initials='R.' surname='Andreasen' fullname='R. Andreasen'><organization /></author>
<date year='2021' month='June' />
<abstract><t>This document defines how to compress Constrained Application Protocol (CoAP) headers using the Static Context Header Compression and fragmentation (SCHC) framework. SCHC defines a header compression mechanism adapted for Constrained Devices. SCHC uses a static description of the header to reduce the header's redundancy and size. While RFC 8724 describes the SCHC compression and fragmentation framework, and its application for IPv6/UDP headers, this document applies SCHC to CoAP headers. The CoAP header structure differs from IPv6 and UDP, since CoAP uses a flexible header with a variable number of options, themselves of variable length. The CoAP message format is asymmetric: the request messages have a header format different from the format in the response messages. This specification gives guidance on applying SCHC to flexible headers and how to leverage the asymmetry for more efficient compression Rules.</t></abstract>
</front>
<seriesInfo name='RFC' value='8824'/>
<seriesInfo name='DOI' value='10.17487/RFC8824'/>
</reference>



<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC7942" target='https://www.rfc-editor.org/info/rfc7942'>
<front>
<title>Improving Awareness of Running Code: The Implementation Status Section</title>
<author initials='Y.' surname='Sheffer' fullname='Y. Sheffer'><organization /></author>
<author initials='A.' surname='Farrel' fullname='A. Farrel'><organization /></author>
<date year='2016' month='July' />
<abstract><t>This document describes a simple process that allows authors of Internet-Drafts to record the status of known implementations by including an Implementation Status section.  This will allow reviewers and working groups to assign due consideration to documents that have the benefit of running code, which may serve as evidence of valuable experimentation and feedback that have made the implemented protocols more mature.</t><t>This process is not mandatory.  Authors of Internet-Drafts are encouraged to consider using the process for their documents, and working groups are invited to think about applying the process to all of their protocol specifications.  This document obsoletes RFC 6982, advancing it to a Best Current Practice.</t></abstract>
</front>
<seriesInfo name='BCP' value='205'/>
<seriesInfo name='RFC' value='7942'/>
<seriesInfo name='DOI' value='10.17487/RFC7942'/>
</reference>



<reference  anchor="RFC7950" target='https://www.rfc-editor.org/info/rfc7950'>
<front>
<title>The YANG 1.1 Data Modeling Language</title>
<author initials='M.' surname='Bjorklund' fullname='M. Bjorklund' role='editor'><organization /></author>
<date year='2016' month='August' />
<abstract><t>YANG is a data modeling language used to model configuration data, state data, Remote Procedure Calls, and notifications for network management protocols.  This document describes the syntax and semantics of version 1.1 of the YANG language.  YANG version 1.1 is a maintenance release of the YANG language, addressing ambiguities and defects in the original specification.  There are a small number of backward incompatibilities from YANG version 1.  This document also specifies the YANG mappings to the Network Configuration Protocol (NETCONF).</t></abstract>
</front>
<seriesInfo name='RFC' value='7950'/>
<seriesInfo name='DOI' value='10.17487/RFC7950'/>
</reference>



<reference  anchor="RFC9011" target='https://www.rfc-editor.org/info/rfc9011'>
<front>
<title>Static Context Header Compression and Fragmentation (SCHC) over LoRaWAN</title>
<author initials='O.' surname='Gimenez' fullname='O. Gimenez' role='editor'><organization /></author>
<author initials='I.' surname='Petrov' fullname='I. Petrov' role='editor'><organization /></author>
<date year='2021' month='April' />
<abstract><t>The Static Context Header Compression and fragmentation (SCHC) specification (RFC 8724) describes generic header compression and fragmentation techniques for Low-Power Wide Area Network (LPWAN) technologies. SCHC is a generic mechanism designed for great flexibility so that it can be adapted for any of the LPWAN technologies.</t><t>This document defines a profile of SCHC (RFC 8724) for use in LoRaWAN networks and provides elements such as efficient parameterization and modes of operation.</t></abstract>
</front>
<seriesInfo name='RFC' value='9011'/>
<seriesInfo name='DOI' value='10.17487/RFC9011'/>
</reference>


<reference anchor="I-D.ietf-lpwan-architecture">
   <front>
      <title>LPWAN Static Context Header Compression (SCHC) Architecture</title>
      <author fullname="Alexander Pelov">
	 <organization>Acklio</organization>
      </author>
      <author fullname="Pascal Thubert">
	 <organization>Cisco Systems</organization>
      </author>
      <author fullname="Ana Minaburo">
	 <organization>Acklio</organization>
      </author>
      <date month="November" day="26" year="2021" />
      <abstract>
	 <t>   This document defines the LPWAN SCHC architecture.

	 </t>
      </abstract>
   </front>
   <seriesInfo name="Internet-Draft" value="draft-ietf-lpwan-architecture-01" />
   <format type="TXT" target="https://www.ietf.org/archive/id/draft-ietf-lpwan-architecture-01.txt" />
</reference>




    </references>



  </back>

<!-- ##markdown-source:
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
KhZ3VKMhAQA=

-->

</rfc>

